## ams_version=1.0

Model Main_Knapsack {
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
			Quantity SI_Mass {
				BaseUnit: lb;
				Conversions: {
					kg -> lb : # -> # * 2.204622476,
					oz -> lb : # -> # * 0.06249998898
				}
				Comment: "Expresses the value for the amount of matter.";
			}
			Quantity q_monetary {
				BaseUnit: $;
			}
			Quantity SI_Unitless {
				BaseUnit: -;
				Conversions: % -> - : # -> # / 100;
				Comment: "Expresses a dimensionless value.";
			}
		}
		Section Inputs {
			Section Items {
				Set s_items {
					Index: i_item;
					Parameter: ep_selectedItem;
					Comment: "ElementRange(1, p_maxItems, prefix:\"item-\", fill:1)";
				}
				Parameter p_maxItems {
					Text: "No. of items";
					Range: integer;
					InitialData: 14;
				}
				Parameter p_itemValue {
					IndexDomain: (i_item);
					Unit: $;
				}
				Parameter p_itemWeight {
					IndexDomain: (i_item);
					Unit: lb;
				}
				Parameter p_maxWeightKnapsack {
					Text: "Max. weight knapsack";
					Unit: lb;
					InitialData: 60;
				}
				Parameter p_itemRangeMin {
					IndexDomain: (i_item);
					Range: integer;
				}
				Parameter p_itemRangeMax {
					IndexDomain: (i_item);
					Range: integer;
				}
				Parameter p_itemBound {
					IndexDomain: (i_item);
					Text: "No. of copies that is allowed";
					Range: integer;
				}
			}
			Procedure pr_randomizeData {
				Body: {
					empty p_itemValue, p_itemWeight, p_itemBound;
					
					p_itemValue(i_item) := uniform(0,200)*1[$];
					p_itemWeight(i_item) := uniform(0[lb],p_maxWeightKnapsack/3);
					p_itemBound(i_item) := ceil(uniform(0,10));
				}
			}
		}
		Section Math_Model {
			Variable v_knapsackItems {
				IndexDomain: i_item;
				Text: "Item i is placed in knapsack";
				Range: {
					{p_itemRangeMin(i_item)..p_itemRangeMax(i_item)}
				}
			}
			Variable v_knapsackValue {
				IndexDomain: i_item;
				Unit: $;
				Definition: {
					v_knapsackItems(i_item) 
					* p_itemValue(i_item)
				}
			}
			Variable v_knapsackTotalValue {
				Unit: $;
				Definition: sum(i_item, v_knapsackItems(i_item) * p_itemValue(i_item));
			}
			Constraint c_limitKnapsackWeight {
				Unit: lb;
				Definition: sum(i_item, v_knapsackItems(i_item) * p_itemWeight(i_item)) <= p_maxWeightKnapsack;
			}
			MathematicalProgram mp_knapsackModel {
				Objective: v_knapsackTotalValue;
				Direction: maximize;
				Type: MIP;
			}
			DeclarationSection Model_Information {
				ElementParameter ep_programStatus {
					Range: AllSolutionStates;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_gap {
					Unit: %;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_numberOfConstraints {
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_numberOfVariables {
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_solutionTime {
					Unit: s;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
			}
			Procedure pr_solveKnapsackModel {
				Body: {
					/* Standard model allows at most 1 copy of each item */
					
					p_itemRangeMin(i_item) := 0;
					p_itemRangeMax(i_item) := 1;
					
					solve mp_knapsackModel;
					
					pr_modelInformation;
				}
			}
			Procedure pr_solveKnapsackModelUnBounded {
				Body: {
					/* Standard model allows at most a specific no of copies of each item */
					
					p_itemRangeMin(i_item) := 0;
					p_itemRangeMax(i_item) := inf;
					
					solve mp_knapsackModel;
					
					pr_modelInformation;
				}
			}
			Procedure pr_solveKnapsackModelBounded {
				Body: {
					/* Standard model allows at most a specific no of copies of each item */
					
					p_itemRangeMin(i_item) := 0;
					p_itemRangeMax(i_item) := p_itemBound(i_item);
					
					solve mp_knapsackModel;
					
					pr_modelInformation;
				}
			}
			Procedure pr_modelInformation {
				Body: {
					empty Model_Information;
					
					ep_programStatus := mp_knapsackModel.ProgramStatus;
					p_gap := abs(1 - (mp_knapsackModel.Objective/$mp_knapsackModel.BestBound));
					p_solutionTime := mp_knapsackModel.SolutionTime;
					p_numberOfConstraints := mp_knapsackModel.NumberOfConstraints;
					p_numberOfVariables := mp_knapsackModel.NumberOfVariables;
				}
			}
		}
	}
	Section UI_Declarations {
		StringParameter sp_logo {
			Definition: "aimms_logo.png";
		}
		Section Workflow {
			StringParameter sp_myWorkflows {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			}
			StringParameter sp_myWorkflowSteps {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
				Definition: {
					{ ( '1', '1', 'displayText'       ) : "Welcome"            ,  ( '1', '1', 'icon'              ) : "aimms-happy"        ,
					  ( '1', '1', 'pageId'            ) : "home"               ,  ( '1', '1', 'tooltip'           ) : "welcome"            ,
					  ( '1', '1', 'workflowPageState' ) : "active"             ,  ( '1', '1', 'pageDataState'     ) : "Incomplete"         ,
					  ( '1', '1', 'redirectPageId'    ) : "home"               ,  ( '1', '2', 'displayText'       ) : "Story"              ,
					  ( '1', '2', 'icon'              ) : "aimms-lamp5"        ,  ( '1', '2', 'pageId'            ) : "problem_description",
					  ( '1', '2', 'tooltip'           ) : "Problem description",  ( '1', '2', 'workflowPageState' ) : "active"             ,
					  ( '1', '2', 'pageDataState'     ) : "Incomplete"         ,  ( '1', '2', 'redirectPageId'    ) : "home"               ,
					  ( '1', '3', 'displayText'       ) : "Inputs"             ,  ( '1', '3', 'icon'              ) : "aimms-equalizer2"   ,
					  ( '1', '3', 'pageId'            ) : "inputs"             ,  ( '1', '3', 'tooltip'           ) : "Input data"         ,
					  ( '1', '3', 'workflowPageState' ) : "active"             ,  ( '1', '3', 'pageDataState'     ) : "Incomplete"         ,
					  ( '1', '3', 'redirectPageId'    ) : "home"               ,  ( '1', '4', 'displayText'       ) : "Results"            ,
					  ( '1', '4', 'icon'              ) : "aimms-make-group"   ,  ( '1', '4', 'pageId'            ) : "results"            ,
					  ( '1', '4', 'tooltip'           ) : "Model outputs"      ,  ( '1', '4', 'workflowPageState' ) : if (not p_solutionTime) then "inactive" else "active" endif,
					  ( '1', '4', 'pageDataState'     ) : "Incomplete"         ,  ( '1', '4', 'redirectPageId'    ) : "home"                }
				}
			}
		}
		Section CRUD {
			StringParameter sp_addEditElement;
			Section CRUD_Items {
				Procedure pr_openAddItem {
					Body: {
						empty sp_addEditElement;
						
						webui::OpenDialogPage(
							pageId  :  'crud', 
							title   :  "Add Items", 
							actions :  s_loc_actions, 
							onDone  :  'pr_addItem');
					}
					Set s_loc_actions {
						InitialData: {
							{'Cancel', 'OK'}
						}
					}
				}
				Procedure pr_addItem {
					Arguments: sp_arg_action;
					Body: {
						if sp_arg_action = 'OK' then
						    ep_selectedItem := StringToElement(s_items, sp_addEditElement, 1);
						endif;
					}
					StringParameter sp_arg_action {
						Property: Input;
					}
				}
				Procedure pr_openEditItem {
					Body: {
						sp_addEditElement := ep_selectedItem;
						
						webui::OpenDialogPage(
							pageId  :  'crud', 
							title   :  "Edit Restaurant", 
							actions :  s_loc_actions, 
							onDone  :  'pr_editItem');
					}
					Set s_loc_actions {
						InitialData: {
							{'Cancel', 'OK'}
						}
					}
				}
				Procedure pr_editItem {
					Arguments: sp_arg_action;
					Body: {
						if sp_arg_action = 'OK' then
						    SetElementRename(s_items, ep_selectedItem, sp_addEditElement);
						endif;
					}
					StringParameter sp_arg_action {
						Property: Input;
					}
				}
				Procedure pr_deleteItem {
					Body: {
						s_items -= ep_selectedItem;
						
						ep_selectedItem := first(i_item);
					}
				}
			}
		}
		Section Pages {
			Section Inputs_Page;
			Section Results_Page {
				DeclarationSection Result_Side_Panel {
					StringParameter sp_resultsSidePanel {
						IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
						Definition: {
							data 
							{ ( 1, displayText ) : "KPIs"             ,  ( 1, pageId      ) : "informations"     ,
							  ( 1, icon        ) : "aimms-question"   ,  ( 1, state       ) : "active"           ,
							  ( 2, displayText ) : "Model Information",  ( 2, pageId      ) : "model_information",
							  ( 2, icon        ) : "aimms-info"       ,  ( 2, state       ) : "active"            }
						}
					}
					Parameter p_itemFilter {
						IndexDomain: i_item;
					}
				}
			}
		}
		Section FlagsIdentifier {
			StringParameter sp_readOnlyFlag {
				Definition: "readonly";
			}
		}
	}
	Section Integration {
		Procedure pr_readAll;
		Procedure pr_writeAll;
	}
	Procedure MainInitialization {
		Comment: "Add initialization statements here that do NOT require any library being initialized already.";
	}
	Procedure PostMainInitialization {
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainExecution;
	Procedure PreMainTermination {
		Body: {
			return DataManagementExit();
		}
		Comment: {
			"Add termination statements here that require all libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
}
